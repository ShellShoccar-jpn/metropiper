#! /bin/sh

######################################################################
#
# GET_LOCTBL_FY.SH
# 列車接近情報テーブルを生成(副都心線・有楽町線仕様)
# Written by Rich Mikan(richmikan@richlab.org) at 2014/11/13
#
# [入力]
# ・引数で下記を指定
#     $1 : 今見たい駅の駅ナンバー
#     $2 : 行先を指示するための駅ナンバー(同じ路線であること)
# ・下記のファイルを用意しておく
#    1. CONF/ACCESSTOKEN.TXT
#       コンテストで与えられたアクセストークンを記述したテキスト
#    2. DATA/SNUM2RWSN_MST.TXT
#       駅ナンバーから路線名や駅名等を引くマスターファイル
#    3. DATA/METRO_VOC_MST.TXT
#       その他(種別・行先名・車両所有会社名等)のボキャブラリーマスターファイル
#    ※ 2,3のファイルはMK_METRO_MST.SHを実行すると得られる。
# [出力]
# ・列車接近情報を標準出力に出す
# ・フォーマットは次のとおり
#   <1行目>…概要
#     1:3桁駅ナンバー(x000 or x999) 2:路線コード 3:路線名
#     4:知りたい駅コード 5:知りたい駅名 6:発表日時(YYYYMMDDhhmmss)
#     7:アクセス日時(YYYYMMDDhhmmss) 8:次回更新日時(YYYYMMDDhhmmss)
#     9:更新間隔秒数 10:"-"(予約) 11:"-"(予約)
#   <2行目以降>…実際の位置
#     1:3桁駅ナンバー 2:駅コード 3:駅名 4:種別コード 5:種別名
#     6:終着駅コード 7:終着駅名 8:車両所有会社コード 9:車両所有会社名
#     10:標準到着時間(分) 11(NF):知りたい駅からの差(±3桁駅ナンバー値で)
#
# [備考]
# ・要curlコマンド
# ・副都心線・有楽町線用であるため、それ以外の路線では動作しない。
#
######################################################################


######################################################################
# 初期設定
######################################################################

# --- 使用法表示関数定義 ---------------------------------------------
print_usage_and_exit() {
  local s
  s=$(awk 'BEGIN{printf("%070d",0)}' | tr 0 '#')
  awk "f==1&&/^${s}\$/{print;exit} f==0&&/^${s}\$/{f=1} f==1{print;}" "$0" 1>&2
  exit 1
}

# --- このシステムのホームディレクトリー -----------------------------
Homedir="$(d=${0%/*}/; [ "_$d" = "_$0/" ] && d='./'; cd "$d.."; pwd)"

# --- 必要なマスターファイルの存在確認 -------------------------------
# 1)駅ナンバーマスター
if [ ! -f "$Homedir/DATA/SNUM2RWSN_MST.TXT" ]; then
  echo "${0##*/}: The master file (SNUM2RWSN_MST.TXT) is not found." 1>&2
  exit 1
fi
# 2)各種ボキャブラリーマスター
if [ ! -f "$Homedir/DATA/METRO_VOC_MST.TXT" ]; then
  echo "${0##*/}: The master file (SNUM2RWSN_MST.TXT) is not found." 1>&2
  exit 1
fi

# --- アクセストークン・APIエンドポイントを設定 ----------------------
s=$Homedir/CONF/ACCESSTOKEN.TXT
[ -f "$s" ] || { echo "${0##*/}: ACCESSTOKEN.TXT not found" 1>&2; exit 1; }
appid=$(env - awk '/^[[:alnum:]]+$/' "$s")
[ -n "$appid" ] || { echo "${0##*/}: Invaid access token" 1>&2; exit 1; }
s=$Homedir/CONF/API_DATAPOINTS.TXT
[ -f "$s" ] || { echo "${0##*/}: API_DATAPOINTS.TXT not found" 1>&2; exit 1; }
urlbase=$(grep -E '^https?://[a-z0-9.-]+(/[!-~]*)?$' "$s")
[ -n "$urlbase" ] || { echo "${0##*/}: Invaid API datapoints" 1>&2; exit 1; }

# --- その他定義 -----------------------------------------------------
# 1)コマンドパスの追加
PATH="$Homedir/UTL:$Homedir/TOOL:$PATH"
# 2)一時ファイル格納先
Tmp=/tmp/${0##*/}.$$
# 3)終了時の一時ファイル削除設定
exit_trap() { rm -f $Tmp-*; }
trap "exit_trap" EXIT HUP INT QUIT PIPE ALRM TERM
# 4)現在日時を取得
now=$(date '+%Y %m %d %H %M %S')


######################################################################
# 引数確認・取得
######################################################################

# --- 書式の正当性確認 -----------------------------------------------
[ $# -eq 2 ] || print_usage_and_exit
echo "_$1" | grep -iq '^_[A-Z][0-9][0-9]$' || print_usage_and_exit
echo "_$2" | grep -iq '^_[A-Z][0-9][0-9]$' || print_usage_and_exit

# --- 駅ナンバーの存在確認 -------------------------------------------
printf '%s\n%s\n' $1 $2                          |
sort                                             |
join -1 1 -2 1 $Homedir/DATA/SNUM2RWSN_MST.TXT - |
awk '{print} END{exit (NR>=2)?0:1}'              > $Tmp-2stns
if [ $? -ne 0 ]; then
  echo "${0##*/}: 存在しない駅ナンバーが指定されています。" 1>&2
  exit 2
fi

# --- 同一路線の駅ナンバーであることの確認 ---------------------------
cat $Tmp-2stns              |
sed 's/^\(.\).*/\1/'        |
tr a-z A-Z                  |
uniq                        |
awk 'END{exit (NR==1)?0:1}'
if [ $? -ne 0 ]; then
  echo "${0##*/}: 異なる路線の駅ナンバーは指定できません。" 1>&2
  exit 2
fi

# --- 副都心線・有楽町線の駅ナンバーであることの確認 -----------------
cat $Tmp-2stns          |
sed 's/^\(.\).*/\1/'    |
tr a-z A-Z              |
uniq                    |
awk '/^[^FY]/{exit 1;}'
if [ $? -ne 0 ]; then
  echo "${0##*/}: 副都心線・有楽町線以外の駅ナンバーが指定されています。" 1>&2
  exit 2
fi

# --- 駅ナンバー変数をセット -----------------------------------------
from_snum=$1
to_snum=$2

# --- 表示方向を決める(駅ナンバー昇順なら0、降順なら1) ---------------
n=$(expr "${to_snum##*[A-Za-z]}" - "${from_snum##*[A-Za-z]}")
if   [ $n -lt 0                           ]; then
  # 引数の順番が駅ナンバー順と反対方面だったら逆方向
  prndir=1
elif [ $n -gt 0                           ]; then
  # 引数の順番が駅ナンバー順と同一方面だったら順方向
  prndir=0
elif [ "${from_snum##*[A-Za-z]}" -le '06' ]; then
  # 引数の駅ナンバーが両方とも同一で06番(小竹向原)以上だったら逆方向
  prndir=1
else
  # 引数の駅ナンバーが両方とも同一で06番(小竹向原)より大きかったら順方向
  prndir=0
fi


######################################################################
# API呼び出し準備(路線コードと方面コードの決定)
######################################################################

# --- 当該路線駅ナンバーマスターファイルの作成 -----------------------
cat $Homedir/DATA/SNUM2RWSN_MST.TXT |
# 1:駅ナンバー 2:路線コード 3:路線名 4:路線駅コード 5:駅名 6:方面駅コード
grep "^[FY]"                        | # 副都心・有楽町線のみに絞り込む
tee $Tmp-fy-rw-stn-mst              | # 副都心・有楽町線の路線駅マスター
grep "^${from_snum%%[0-9]*}"        | # 指定路線のみに絞り込む
tee $Tmp-this-rw-stn-mst            | # 指定路線のみの路線駅マスター
awk '$6!="-"'                       > $Tmp-dirstns # 方面駅コードを持つ駅のみに絞り込む

# --- 駅コードから駅ナンバーを引くマスターファイルを作る -------------
cat $Tmp-fy-rw-stn-mst |
# 1:駅ナンバー 2:路線コード 3:路線名 4:路線駅コード 5:駅名 6:方面駅コード
awk '{print $4,$1}'    |
# 1:路線駅コード 2:駅ナンバー
sort -k1,1             > $Tmp-sc2snum

# --- 路線コード・路線文字の取得 -------------------------------------
rwcode=$(awk '{print $2;exit;}' $Tmp-dirstns)
rwletter=${from_snum%%[0-9]*}

# --- 同一の途中駅を指定していないか確認 -----------------------------
case "$from_snum" in
  "$to_snum") cat $Tmp-sc2snum                   | # このファイルは副都心・有楽町混合なので
              awk '$2~/^'"$rwletter"'/'          | # 指定路線のみに絞り込んでから
              sort -k2,2                         | # 検査する
              awk 'NR==1{s=$2;} END{print s,$2}' |
              grep -q "$from_snum"              ;;
  *)          :;;
esac
case $? in
  0) :;;
  *) echo "${0##*/}: 方面が特定できません。同じ駅ナンバーを指定していませんか?" 1>&2
     exit 2;;
esac


######################################################################
# 列車ロケーション情報API呼び出しと、キャッシュ作成
# (キャッシュの有効期限が切れているならば)
######################################################################

# --- 副都心線・有楽町線で2回ループ(ループ開始端) --------------------
File_caches=''
for rwc in odpt.Railway:TokyoMetro.Fukutoshin odpt.Railway:TokyoMetro.Yurakucho
do

# --- キャッシュファイル名の設定 -------------------------------------
File="$Homedir/TMP/odpt:Train-$rwc.cache.txt"

# --- 呼び出しURLの設定 ----------------------------------------------
url="$urlbase?rdf:type=odpt:Train&odpt:railway=$rwc&acl:consumerKey=$appid"

# --- 有効期限内の指定路線のキャッシュファイルはあるか?(あれば戻り値0)
touch $Tmp-now # 現在日時タイムスタンプを持つファイルを作る
mkdir -p "${File%/*}"
find "${File%/*}" -name "${File##*/}" -newer $Tmp-now                |
awk 'BEGIN                                              {f=0;     }  #
     index(substr($0,length("'"${File%/*}"'")+2),"/")==0{f=1;     }  #
     END                                                {exit 1-f;}'
cache_is_fresh=$((1-$?))

# --- 有効キャッシュがなければ作る -----------------------------------
case $cache_is_fresh in
  0) success=0; try=3
     while [ $try -gt 0 ]; do      # 通信エラーは3回試す。
       try=$((try-1))
       curl -sf $url > $Tmp-curl
       case $? in
         0)    :                ;; # 正常
         22)   sleep 3; continue;; # アクセス高頻度エラー等
         *)    continue         ;; # curlそのもののエラー
       esac
       [ -s $Tmp-curl ] || {
               sleep 3; continue;  # その他サーバーエラー
       }
       case "$(head -c 1 $Tmp-curl)" in
         [{[]) :;;                 # 恐らく正常なJSONである
         *)    sleep 3; continue;; # JSONデータではない
       esac
       parsrj.sh $Tmp-curl > "$File"
       success=1
       break
     done
     case $success in
       0) echo "${0##*/}: 通信エラー、暫く経ってからやり直してください" 1>&2
          exit 2
          ;;
     esac
     ;;
esac

# --- キャッシュ中に存在するデータ生成日時と有効期限日時を読み取る ---
cat "$File"                                                         |
awk '$1~/\.dc:date$/       {printf("d %s -\n"               ,$2);}  #
     $1~/\.odpt:frequency$/{printf("f 19700101000000 %05d\n",$2);}  #
     $1~/\.dct:valid$/     {printf("v %s -\n"               ,$2);}' > $Tmp-timeinfo
# 1:識別子(情報日時なら"d"、有効期限日時なら"v"、更新頻度なら"f")
# 2:"d","v"の時…日時(ISO8601形式)、"f"の時…Epoch日時
# 3:"f"の時…更新頻度(秒)、"d"と"v"の時…"-"(ダミー)
if [ -s $Tmp-timeinfo ]; then
  cat $Tmp-timeinfo                                                          |
  sort                                                                       |
  getfirst 1 1                                                               |
  # 1:識別子(情報日時なら"d"、有効期限日時なら"v"、更新頻度なら"f")          #
  # 2:"d","v"の時…最古の日時(ISO8601形式)、"f"の時…ダミー日時              #
  # 3:"f"の時…最小の更新頻度(秒)、"d"と"v"の時…"-"(ダミー)                 #
  sed '/^[dv]/s/\(.\{6\}\) -$/ \1/'                                          |
  awk '/^[dv]/{gsub(/[^0-9]/,"",$2);$3=substr($3,1,3)*3600+substr($3,5)*60}  #
              {print;                                                     }' |
  # 1:識別子(情報日時なら"d"、有効期限日時なら"v"、更新頻度なら"f")          #
  # 2:"d","v"の時…最古の日時(現地時間のYYYYMMDDHHMMSS)、"f"の時…Epoch日時  #
  # 3:"f"の時…最小の更新頻度(秒)、"d"と"v"の時…UTCからの秒数               #
  TZ=UTC+0 calclock 2                                                        |
  awk '/^d/{d=$3-$4;                   }                                     # # 現在は、vは直値を見ず
       /^v/{v=$3-$4;                   }                                     # # dとfから計算して求める
       /^f/{f=$4;                      }                                     # # (v=d+f)
       END {print "d",d; print "v",d+f;}'                                    |
  # 1:識別子("d"or"v") 2:左記の最古の日時(UNIX時間)                          #
  calclock -r 2                                                              |
  self 1 3                                                                   |
  # 1:識別子("d"or"v") 2:左記の最古の日時(現地時間のYYYYMMDDHHMMSS)          #
  sed 's/[0-9][0-9]/ &/g'                                                    |
  sed 's/ \([0-9][0-9]\) /\1/'                                               |
  # 1:識別子("d"or"v") 2:左記の最古の日時(現地時間のYYYY MM DD HH MM SS)     #
  grep -E '^[dv] [0-9]{4} [0-9]{2} [0-9]{2} [0-9]{2} [0-9]{2} [0-9]{2}$'     >> $Tmp-timestamps0
else
  # 営業休止時間帯等、データが取れなかったら現在日時を入れる
  printf 'd %s %s %s %s %s %s\nv %s %s %s %s %s %s\n' $now $now >> $Tmp-timestamps0
fi

# --- キャッシュファイルのタイムスタンプを有効期限日時にする ---------
if [ $cache_is_fresh -eq 0 ]; then
  s=$(cat $Tmp-timestamps0                       |
      awk '$1=="v"{print $2 $3 $4 $5 $6 "." $7}' |
      tail -n 1                                  )
  touch -t $s "$File"
fi

# --- 必要なキャッシュの一覧に加える ---------------------------------
File_caches="$File_caches $File"

# --- 副都心線・有楽町線で2回ループ(ループ終了端) --------------------
done

# --- キャッシュ群のファイルのタイムスタンプを統合する ---------------
cat $Tmp-timestamps0 |                
sort                 |
getfirst 1 1         >  $Tmp-timestamps
echo "a $now"        >> $Tmp-timestamps # APIへのアクセス日時を追加する


######################################################################
# API取得データ(列車ロケーション情報の取得)の加工
######################################################################

# --- 必要な項目・区間&方面のみに絞り込んだ在線位置マスターファイルを作る
i=0
for f in $File_caches; do    # 副都心・有楽町混合につきレコード番号重複回避用#
  awk '$1!~/:/{next;}                                                        #
       match($1,/^\$\[[0-9]+\]\./){                                          #
         n=substr($0,3,RLENGTH-4)+1000*'$i';                                 #
         f1=$1; sub(/^.*:/,"",f1);                                           #
         print n,f1,$2;                                                      #
       }' $f                                                                 #
  i=$((i+1))                                                                 #
done                                                                         |
# 1:レコード番号 2:列名 3:値                                                 #
awk '$2=="railDirection"  {$2=1;print;next;}                                 #
     $2=="fromStation"    {$2=2;print;next;}                                 #
     $2=="toStation"      {$2=3;print;next;}                                 #
     $2=="trainType"      {$2=4;print;next;}                                 #
     $2=="startingStation"{$2=5;print;next;}                                 #
     $2=="terminalStation"{$2=6;print;next;}                                 #
     $2=="trainOwner"     {$2=7;print;next;}'                                |
sort -k1n,2n                                                                 |
delf 2                                                                       |
yarr num=1                                                                   |
delf 1                                                                       |
# 1:方面コード 2:発車駅コード 3:到着駅コード 4:種別コード 5:始発駅コード     #
# 6:終着駅コード 7:車両所有会社コード                                        #
awk '{# 方面コードに基づいてその路線のその方面の駅コード列を生成する         #
      s1=$1;sub(/^.+\./ ,"",s1); # ←駅名のみ                                #
      s2=$2;sub(/[^.]+$/,"",s2); # ←駅名のうち路線名部分まで                #
      print $1,s2 s1,$2,$3,$4,$5,$6,$7;                             }'       |
# 1:方面コード 2:方面に相当する駅コード 3:発車駅コード 4:到着駅コード        #
# 5:種別コード 6:始発駅コード  7:終着駅コード 8:車両所有会社コード           #
sort -k2,2                                                                   |
join -1 1 -2 2 -o 2.1,2.2,1.2,2.3,2.4,2.5,2.6,2.7,2.8 $Tmp-sc2snum -         |
# 1:方面コード 2:方面相当駅コード 3:方面相当駅ナンバー 4:発車駅コード        #
# 5:到着駅コード 6:種別コード 7:始発駅コード 8:終着駅コード                  #
# 9:車両所有会社コード                                                       #
sort -k4,4                                                                   |
join -1 1 -2 4 -o 2.1,2.2,2.3,2.4,1.2,2.5,2.6,2.7,2.8,2.9 $Tmp-sc2snum -     |
# 1:方面コード 2:方面相当駅コード 3:方面相当駅ナンバー 4:発車駅コード        #
# 5:発車駅ナンバー 6:到着駅コード 7:種別コード 8:始発駅コード 9:終着駅コード #
# 10:車両所有会社コード                                                      #
sort -k6,6                                                                   |
join -1 1 -2 6 -a 2 -e '-' -o 2.1,2.2,2.3,2.4,2.5,2.6,1.2,2.7,2.8,2.9,2.10 $Tmp-sc2snum - |
# 1:方面コード 2:方面相当駅コード 3:方面相当駅ナンバー 4:発車駅コード        #
# 5:発車駅ナンバー 6:到着駅コード 7:到着駅ナンバー(無い場合は"-") 8:種別コード
# 9:始発駅コード 10:終着駅コード 11:車両所有会社コード                       #
sort -k9,9                                                                   |
join -1 1 -2 9 -a 2 -e '-' -o 2.1,2.2,2.3,2.4,2.5,2.6,2.7,2.8,2.9,1.2,2.10,2.11 $Tmp-sc2snum - |
# 1:方面コード 2:方面相当駅コード 3:方面相当駅ナンバー 4:発車駅コード        #
# 5:発車駅ナンバー 6:到着駅コード 7:到着駅ナンバー(無い場合は"-") 8:種別コード
# 9:始発駅コード  10:始発駅ナンバー(メトロ駅外は"-") 11:終着駅コード         #
# 12:車両所有会社コード                                                      #
sort -k11,11                                                                 |
join -1 1 -2 11 -a 2 -e '-' -o 2.1,2.2,2.3,2.4,2.5,2.6,2.7,2.8,2.9,2.10,2.11,1.2,2.12 $Tmp-sc2snum - |
# 1:方面コード 2:方面相当駅コード 3:方面相当駅ナンバー 4:発車駅コード        #
# 5:発車駅ナンバー 6:到着駅コード 7:到着駅ナンバー(無い場合は"-") 8:種別コード
# 9:始発駅コード 10:始発駅ナンバー(メトロ駅外は"-") 11:終着駅コード          #
# 12:終着駅ナンバー(メトロ駅外は"-") 13:車両所有会社コード                   #
self 1 3 5 7 9 10 12 8 11 13                                                 |
# 1:方面コード 2:方面相当駅ナンバー 3:発車駅ナンバー                         #
# 4:到着駅ナンバー(無い場合は"-") 5:始発駅コード                             #
# 6:始発駅ナンバー(メトロ駅外は"-")  7:終着駅ナンバー(メトロ駅外は"-")       #
# 8:種別コード 9:終着駅コード 10:車両所有会社コード                          #
awk -v dir=$prndir -v rwl=$rwletter '{                                       #
    rwl = $3; sub(/[0-9]+$/,"",rwl);                                         # # 副都心・有楽町混合特別仕様で
    # 在線中3桁駅ナンバーを求める                                            # # 路線文字はレコード毎に抽出している
    if ($4 == "-") {                                                         #
      csnum3 = $3 "0";                                                       #
    } else {                                                                 #
      fno    = substr($3,length(rwl)+1)*10;                                  #
      tno    = substr($4,length(rwl)+1)*10;                                  #
      csnum3 = sprintf("%s%03d",rwl,fno+(tno-fno)/2);                        #
    }                                                                        #
    # メトロ線内始発3桁駅ナンバーを求める                                    #
    if ($6 != "-") {                                                         #
      fsnum3 = $6 "0";                                                       #
    } else if (match($5,/^odpt\.Station:Tobu\./)) {                          # # ←東武線内駅始発なら
      fsnum3 = rwl "010";                                                    # #   和光市(x01)から入線する
    } else if (match($5,/^odpt\.Station:Seibu\./)) {                         # # ←西武線内駅始発なら
      fsnum3 = rwl "060";                                                    # #   小竹向原(x06)から入線する
    } else if (match($5,/^odpt\.Station:Tokyu\./)) {                         # # ←東急線内駅始発なら
      fsnum3 = "F160";                                                       # #   渋谷(F16)から入線する
    } else if (match($5,/^odpt\.Station:Minatomirai\./)) {                   # # ←みなとみらい線内駅始発なら
      fsnum3 = "F160";                                                       # #   渋谷(F16)から入線する
    }                                                                        #
    # メトロ線内終着3桁駅ナンバーを求める                                    #
    tsnum3 = ($7!="-") ? $7 "0" : $2 "0";                                    #
    #                                                                        #
    print $1,csnum3,fsnum3,tsnum3,$8,$9,$10;                                 #
  }'                                                                         |
# 1:方面コード 2:在線中3桁駅ナンバー(3桁目は0または5で、5は中間にいることを表す)
# 3:メトロ線内始発3桁駅ナンバー 4:メトロ線内終着3桁駅ナンバー                #
# 5:種別コード 6:終着駅コード 7:車両所有会社コード                           #
awk '$2~/^.(0[1-5]|060)/{print;next;}                                        # # 副都心・有楽町共用区間と
     substr($2,1,length("'"$rwletter"'"))=="'"$rwletter"'"{print;next;}'     | # 「知りたい駅」路線のみに絞り込む
awk '(substr($3,length("'"$rwletter"'")+1)>substr($4,length("'"$rwletter"'")+1))=='$prndir'{print;}' | # 方向一致する列車のみに絞り込む
awk -v dir=$prndir -v fsnum="$from_snum" '                                   #
  # 「知りたい駅」を通らない列車については、到着分数を計算させない           #
  BEGIN{ano=fsnum; sub(/^[A-Z]+/,"",ano); ano*=10;}                          #
  { rwl=$2;sub(/[0-9]+$/,"",rwl);                                            #
    fno=$3;sub(/^[A-Z]+/,"",fno); fno*=1;                                    #
    tno=$4;sub(/^[A-Z]+/,"",tno); tno*=1;                                    #
    mk_minsindex=0;                                                          #
    if ((dir==0) && (ano>=fno) && (ano<=tno)) {mk_minsindex=1;}              #
    if ((dir==1) && (ano>=tno) && (ano<=fno)) {mk_minsindex=1;}              #
    minsindex = (mk_minsindex) ? sprintf("%s/%s/%s%03d",$5,$2,rwl,ano):"-";  #
    print $2,$5,$6,$7,minsindex;                                             #
  }'                                                                         |
# 1:現在居る3桁駅ナンバー(3桁目は0または5で、5は中間にいることを表す)        #
# 2:種別コード 3:終着駅コード 4:車両所有会社コード 5:所要時間計算用index     #
awk '{sub(/^[A-Z]+/,"'"$rwletter"'",$1);print;}'                             | # 副都心・有楽町混在の在線中駅ナンバーを自路線に統一する
sort -k5,5                                                                   |
join -1 1 -2 5 -a 2 -e '-' -o 2.1,2.2,2.3,2.4,2.5,1.2 "$Homedir/DATA/RWMINS_odpt.Railway:TokyoMetro.FY_${prndir}.TXT" - |
self 1 2 3 4 6                                                               > $Tmp-this-rw-dir-loc
# 1:現在居る3桁駅ナンバー 2:種別コード 3:終着駅コード 4:車両所有会社コード   #
# 5:標準到着時間(分)

# --- コードを名称化し、列車存在位置から列車名を引くマスターファイルを作る
cat $Tmp-this-rw-dir-loc                                                                        |
# 1:現在居る3桁駅ナンバー 2:種別コード 3:終着駅コード 4:車両所有会社コード 5:標準到着時間(分)   #
sort -k2,2                                                                                      |
join -1 1 -2 2 -a 2 -e '-' -o 2.1,2.2,1.2,2.3,2.4,2.5 $Homedir/DATA/METRO_VOC_MST.TXT -         |
sed 's/\([^. ]\{1,\}\) - /\1 \1 /'                                                              |
# 1:現在居る3桁駅ナンバー 2:種別コード 3:種別名 4:終着駅コード 5:車両所有会社コード 6:標準到着時間(分)
sort -k4,4                                                                                      |
join -1 1 -2 4 -a 2 -e '-' -o 2.1,2.2,2.3,2.4,1.2,2.5,2.6 $Homedir/DATA/METRO_VOC_MST.TXT -     |
sed 's/\([^. ]\{1,\}\) - /\1 \1 /'                                                              |
# 1:現在居る3桁駅ナンバー 2:種別コード 3:種別名 4:終着駅コード 5:終着駅名 6:車両所有会社コード 7:標準到着時間(分)
sort -k6,6                                                                                      |
join -1 1 -2 6 -a 2 -e '-' -o 2.1,2.2,2.3,2.4,2.5,2.6,1.2,2.7 $Homedir/DATA/METRO_VOC_MST.TXT - |
sed 's/\([^. ]\{1,\}\) - /\1 \1 /'                                                              |
# 1:現在居る3桁駅ナンバー 2:種別コード 3:種別名 4:終着駅コード 5:終着駅名 6:車両所有会社コード 7:車両所有会社名 8:標準到着時間(分)
sort -k1,1                                                                                      > $Tmp-this-rw-loc


######################################################################
# 最終出力の作成
######################################################################

# --- 駅間を含む3桁駅ナンバーから駅名を得るマスターファイルを作る ----
#
cat $Tmp-this-rw-stn-mst                                                  |
# 1:駅ナンバー 2:路線コード 3:路線名 4:路線駅コード 5:駅名 6:方面駅コード #
sort -k1,1                                                                |
self 1 4 5                                                                |
# 1:駅ナンバー 2:路線駅コード 3:駅名                                      #
awk '{rwletter = substr($1,1,1);    # 路線アルファベット                  # # 駅間の行を生成する
      n3       = substr($1,2,2)*10; # 3桁駅ナンバーの数字部分             #
      print sprintf("%s%03d",rwletter,n3  ),$2,$3;                        #
      print sprintf("%s%03d",rwletter,n3+5),"-","-";         }'           > $Tmp-snumex2sn # 最後の1行は中間ではないので消す
# 1:3桁駅ナンバー 2:駅コード 3:駅名

# --- 最終出力(1行目)に必要な情報を得る ------------------------------
#
rwinfo=$(awk '$1=="'"$rwcode"'"{print $1,$2;}' $Homedir/DATA/METRO_VOC_MST.TXT)
timestamps=$(cat $Tmp-timestamps                                             |
             awk '$1=="d"{printf("%d %s%s%s%s%s%s\n",1,$2,$3,$4,$5,$6,$7);}  #
                  $1=="a"{printf("%d %s%s%s%s%s%s\n",2,$2,$3,$4,$5,$6,$7);}  #
                  $1=="v"{printf("%d %s%s%s%s%s%s\n",3,$2,$3,$4,$5,$6,$7);}' |
             sort                                                            |
             self 2                                                          |
             tr '\n' ' '                                                     |
             sed 's/ *$//'                                                   )
fromstninfo=$(awk '$1=="'"${from_snum}0"'"{print $2,$3;}' $Tmp-snumex2sn)
interval='90'

# --- 最終出力(2行目以降)を作る --------------------------------------
#
join -1 1 -2 1 -a 2 -o 2.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,2.2,2.3 -e '-'      \
     $Tmp-this-rw-loc $Tmp-snumex2sn                                       |
# 1:3桁駅ナンバー 2:種別コード(居ない時は"-") 3:種別名(居ない時は"-") 4:終着駅コード(居ない時は"-") 5:終着駅名(居ない時は"-") 6:車両所有会社コード(居ない時は"-") 7:車両所有会社名(居ない時は"-") 8:標準到着時間(分) 9:駅コード(中間の場合は"-") 10:駅名(中間の場合は"-")
awk '{print $0,substr($1,length("'$rwletter'")+1)*1-"'"${from_snum##*[A-Za-z]}0"'"*1;}' |
# 1:3桁駅ナンバー 2:種別コード(居ない時は"-") 3:種別名(居ない時は"-") 4:終着駅コード(居ない時は"-") 5:終着駅名(居ない時は"-") 6:車両所有会社コード(居ない時は"-") 7:車両所有会社名(居ない時は"-") 8:標準到着時間(分) 9:駅コード(中間の場合は"-") 10:駅名(中間の場合は"-") 11:知りたい駅からの距離(3桁駅num)
self 1 9 10 2 3 4 5 6 7 8 11                                               |
# 1:3桁駅ナンバー 2:駅コード(中間の場合は"-") 3:駅名(中間の場合は"-") 4:種別コード(居ない時は"-") 5:種別名(居ない時は"-") 6:終着駅コード(居ない時は"-") 7:終着駅名(居ない時は"-") 8:車両所有会社コード(居ない時は"-") 9:車両所有会社名(居ない時は"-") 10:標準到着時間(分) 11:知りたい駅からの距離(3桁駅num)
case $prndir in                                                            #
  # 表示が昇順指示だったら、(昇順のまま)最終行(存在しない駅間)をトル。     #
  0) sed '$d'    |                                                         #
     awk 'BEGIN{print "'"${from_snum%%[0-9]*}000 $rwinfo $fromstninfo $timestamps $interval - -"'"} {print;}'
     ;;                                                                    #
  # 表示が降順指示だったら、降順にして、先頭行(存在しない駅間)をトル。     #
  1) sort -k1r,1 |                                                         #
     sed '1d'    |                                                         #
     awk 'BEGIN{print "'"${from_snum%%[0-9]*}999 $rwinfo $fromstninfo $timestamps $interval - -"'"} {$NF=($NF!=0)?-$NF:$NF;print;}'
     ;;                                                                    #
esac


######################################################################
# 正常終了
######################################################################

exit 0